
// This is an autogenerated file from Firebase Studio.
'use client';
import { db } from '@/firebase';
import type { Order, OrderStatus } from '@/lib/types';
import { collection, getDocs, addDoc, updateDoc, doc, DocumentData, QueryDocumentSnapshot, query, where, serverTimestamp, getDoc } from 'firebase/firestore';
import { errorEmitter } from '@/firebase/error-emitter';
import { FirestorePermissionError } from '@/firebase/errors';

const getOrderCollection = () => collection(db, 'orders');

const fromFirestore = (snapshot: QueryDocumentSnapshot<DocumentData>): Order => {
    const data = snapshot.data();
    const date = data.date?.toDate ? data.date.toDate().toISOString() : new Date().toISOString();
    return {
        ...data,
        id: snapshot.id,
        date: date,
    } as Order;
}

export const getOrdersByUserId = async (userId: string): Promise<Order[]> => {
    const q = query(getOrderCollection(), where("userId", "==", userId));
    try {
        const snapshot = await getDocs(q);
        return snapshot.docs.map(fromFirestore);
    } catch (e) {
        const contextualError = new FirestorePermissionError({
          operation: 'list',
          path: getOrderCollection().path,
        });
        errorEmitter.emit('permission-error', contextualError);
        throw contextualError;
    }
};

export const getOrders = async (): Promise<Order[]> => {
    try {
        const snapshot = await getDocs(getOrderCollection());
        return snapshot.docs.map(fromFirestore);
    } catch (e) {
         const contextualError = new FirestorePermissionError({
          operation: 'list',
          path: getOrderCollection().path,
        });
        errorEmitter.emit('permission-error', contextualError);
        throw contextualError;
    }
};

export const addOrder = async (order: Omit<Order, 'id' | 'date' | 'status' | 'validationCode'>) => {
    const validationCode = Math.floor(100000 + Math.random() * 900000).toString();
    
    const newOrder = {
        ...order,
        date: serverTimestamp(),
        status: 'En attente',
        validationCode,
    }
    try {
        const docRef = await addDoc(getOrderCollection(), newOrder);
        return docRef?.id;
    } catch (e) {
        const contextualError = new FirestorePermissionError({
          operation: 'create',
          path: getOrderCollection().path,
          requestResourceData: newOrder,
        });
        errorEmitter.emit('permission-error', contextualError);
        throw contextualError;
    }
};

export const updateOrderStatus = async (id: string, status: OrderStatus) => {
    const orderDoc = doc(db, 'orders', id);
    updateDoc(orderDoc, { status }).catch(e => {
        const contextualError = new FirestorePermissionError({
            operation: 'update',
            path: orderDoc.path,
            requestResourceData: { status },
        });
        errorEmitter.emit('permission-error', contextualError);
    });
};

export const validateOrderDelivery = async (orderId: string, code: string): Promise<{success: boolean, error?: string}> => {
    const orderDocRef = doc(db, 'orders', orderId);
    try {
        const orderSnapshot = await getDoc(orderDocRef);
        if (!orderSnapshot.exists()) {
            return { success: false, error: "Commande non trouvée." };
        }
        
        const orderData = orderSnapshot.data() as Order;
        
        if (orderData.validationCode !== code) {
            return { success: false, error: "Code de validation incorrect." };
        }

        if (orderData.status !== 'Prêt') {
            return { success: false, error: `La commande ne peut pas être validée car son statut est "${orderData.status}".` };
        }

        // If code is correct and status is 'Prêt', update to 'Livré'
        await updateDoc(orderDocRef, { status: 'Livré' });
        return { success: true };

    } catch (error: any) {
        const contextualError = new FirestorePermissionError({
            operation: 'update',
            path: orderDocRef.path,
            requestResourceData: { status: 'Livré' },
        });
        errorEmitter.emit('permission-error', contextualError);
        // Instead of throwing, return a structured error for the UI
        return { success: false, error: "Une erreur de permission est survenue. Vérifiez les règles de sécurité." };
    }
};
